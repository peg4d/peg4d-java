// PEG4d Python 2 Grammar

File
	= { (_ NL / @TopLevel)* #File}

Chunk
	= TopLevel

TopLevel
	= Statement

W
	= [a-zA-Z0-9_]

NL
	= '\r'? '\n'

S
	= [ \t]

EOS
	= ';'
	/ NL
	/ "#" (!'\n' .)* '\n'

_
	= S*

// Token
// ====

"if"     = 'if' !W
"else"   = 'else' !W
"while"   = 'while' !W
"elif"     = 'elif' !W
"do"     = 'do' !W
"for"    = 'for' !W
"class"   = 'class' !W
"raise"   = 'raise' !W
"with"   = 'with' !W
"continue" = 'continue' !W
"break"    = 'break' !W
"return"   = 'return' !W
"print"    = 'print' !W
"as"       = 'as' !W
"in"       = 'in' !W
"import"   = 'import' !W
"from"     = 'from' !W
"def"      = 'def' !W
"try"      = 'try' !W
"except"   = 'except' !W
"or"       = 'or' !W
"and"      = 'and' !W
"not"      = 'not' !W
"True"     = 'True' !W
"False"    = 'False' !W

"*"      = '*' !'=' _
"+"      = '+' ![+=] _
"-"      = '-' !('-' / [=>]) _
"~"      = '~' _
"!"      = '!' !'=' _
"["      = '[' _
"]"      = ']' _
","      = ',' _
"..."    = '...' _
":"      = _ ':' ![>] _
"/"      = '/' !'=' _
"%"      = '%' ![=>] _
"{"      = '{' !'=' _
"}"      = '}' !'=' _
"<="     = '<=' _
">="     = '>=' _
"<"      = '<' ![=] _
">"      = '>' ![=] _
"=="     = '==' _
"!="     = '!=' _
"^"      = '^' ![=] _
"|"      = '|' ![=] _
"&&"     = '&&' _
"||"     = '||' _
"?"      = '?' _

"/="       = '/=' _;
"%="       = '%=' _
"+="       = '+=' _
"-="       = '-=' _
"&="       = '&=' _
"^="       = '^=' _
"|="       = '|=' _
"="        = '=' !'=' _
"."        = '.' _

"("        = '(' _
")"        = ')' _

// Block, Statement

Statement
	= { "if" @Expr _ @Block (@Elif)* (_ NL* 'else' _ @Block)? #If }
	/ { "while" @Expr @Block #While}
	/ { "for" @Symbol "in" @Expr @Block #ForEach}
	/ { "return" @Expr #Return}
	/ ImportStatement EOS
	/ {"break" #Break}
	/ {"continue" #Continue}
	/ {"def" _  @Symbol "(" @Params ")" @Block #Function}
	/ {"class" @Symbol (S* "(" S* (Extend@)? S* ")" )? @ClassBlock #Class}
	/ {"try" @Block "except" @Expr S* @Block #Try}
	/ {"assert" @Expr (_ "," @Expr)? #Assert}
	/ {"print"  @Expr #Print }
	/ {"raise"  @Expr #Throw }
	/ {"with"   @Expr "as" @Symbol ":" @Block #With}
	/ {'return' _ @Expr #Return}
	/ Expr EOS?
	/ { #Empty } EOS

Elif
	= {"elif" S+ @Expr _ @Block #if }

ImportStatement
	= {"import" @ImportSymbol (S* "," S* @Symbol)* #Import}
	/ {"from" @Symbol "import" @ImportSymbol (S* "," S* @ImportSymbol)* #FromImport}

Extend
	= { @ExtendContent #super }

ExtendContent
	= Symbol

Block
	= { <block ":" _ NL (_ NL / @IndentStatement)+ > #Block}
	/ _ { @Statement #Block}

IndentStatement
	= <indent> S+ Statement

ClassBlock
	= NL+ { <block (S* EOS+ / @ClassStatement EOS?)+ > #Block};

ClassStatement
	= <indent> _ Statement

Expr
	= Assign

Assign
	= OrExpr {@ S* addAssignOp S* OrExpr@}*

addAssignOp
	= '=' !'=' #Assign
	/ '+='     #Addeq
	/ '-='     #Subeq
	/ '*='     #Muleq
	/ '/='     #Diveq

OrExpr
	= AndExpr {@ S* 'or' S* @AndExpr #Or }*

AndExpr
	= BitwiseExpr {@ S* 'and' S* @BitwiseExpr #And }*

BitwiseExpr
	= Equal {@ S* ("|" !'|' #BitOr / "&" !'&' #BitAnd / "^" #BitXor) S* @Equal }*

Equal
	= Relation {@ S*  addEqOp S* @Relation}*

addEqOp
	= 'is' S+ 'not' #Noteq
	/ 'is' #Eq
	/ '==' #Eq
	/ '!=' #Noteq
	/ 'in' #In

Relation
	= Shift {@ S* ('<' !'<' #Lt / '<=' #Lte / '>' !'>' #Gt / '>=' #Gte) S* @Shift }*

Shift
	= Sum {@ S* ("<<" #LShift / ">>" #RShift) S* @Sum }*

Sum
	= Product {@ S* ('+' #Add / '-' #Sub) S* @Product }*

Product
	= Unary {@ S* ("*" #Mul / "/" #Div / "%" #Mod) S* @Unary }*

Unary
	= { ("not" #Not / "!" #Not / "-" #Minus / "+" #Plus / "~" #Compl) @Unary }
	/ Value {@ addSelector }*

addSelector
	= '.' @Symbol #Field
	/ '[' S* (@Slice / @Expr) S* ']' #Index
	/ '(' @{ _* ( _* @Expr ( _* ',' _* @Expr )* )? #Args } ')'  #Apply

Slice
	= { @SliceBegin ":" @SliceEnd #Slice }
	/ { @SliceBegin ":" #Slice }
	/ { ":" @SliceEnd #Slice }

SliceBegin
	= { @Expr #SliceBegin }

SliceEnd
	= { @Expr #SliceEnd }

Value
	= StringLiteral
	/ Symbol
	/ Number
	/ ArrayLiteral
	/ DictLiteral
	/ TupleLiteral

ArrayLiteral
	= { "[" (@Expr)? (_* "," _* @Expr)* _* "]" #Array}
	/ { "[" @Expr "for" @Symbol "in" @Expr (_* "if" Expr@)? _* "]" #ListComprehension }

DictLiteral
	= { "{" _* (@DictContent)? (_* "," _* @DictContent )* _* "}" #Hash}

TupleLiteral
	= "(" Expr ")"
	/ { "(" _* @Expr (_* "," _* @Expr)+ _* ")" #List }

DictContent
	= { (@StringLiteral / @Symbol) ":" @Expr #KeyValue};

Params
	= { (@Param)? (_* "," _* @Param)* _* #Params};

Param
	= { @Symbol (S* "=" @Expr)? #Param }

Args
	= { (@Expr)? (_* "," @Expr)* #Args};

Symbol
	= { "True" #TTrue }
	/ { "False" #TFalse }
	/ { "None" #TNull }
	/ { NAME #Name}

KEYWORD
	= 'if' / 'else' / 'while' / 'elif' / 'do' / 'for' / 'class' / 'raise' / 'with' / 'continue'
	/ 'break' / 'return' / 'print' / 'as' / 'in' / 'import' / 'from' / 'def' / 'try' / 'except'
	/ 'or' / 'and' / 'not' / 'True' / 'False'

NAME
	= !DIGIT !(KEYWORD !W) W+

StringLiteral
	= [bru]? '"""' { ('\\"' / !'"""' .)*  #String } '"""'
	/ [bru]? "'''" { ("\\'" / !"'''" .)*  #String } "'''"
	/ [bru]? '"' { ('\\"' / !'"' .)* #String } '"'
	/ [bru]? "'" { ("\\'" / !"'" .)* #String } "'"

DIGIT = [0-9]

digits = DIGIT+

EXPONENT = [eE] [+-]? digits

FLOAT
	= "." digits EXPONENT?
	/ digits "." EXPONENT
	/ digits (("." (digits EXPONENT?)?) / EXPONENT);

INTEGER
	= "0" [xX] [0-9a-fA-F]+      // hexadecimal integer
	/ "0" [0-7]+                 // octal integer
	/ "0"                        // zero
	/ [1-9] digits?             // decimal integer

Number
	= { ("-" / "+")? FLOAT   #Float }
	/ { ("-" / "+")? INTEGER #Int }

Asterisk
	= { '*' #Asterisk}

ImportSymbol
	= Symbol
	/ Asterisk
